default_platform(:mac)

platform :mac do
  SCHEME = "BatteryBoi - Recharged"
  PROJECT = "BatteryBoi.xcodeproj"
  BUNDLE_ID = "com.nirnshard.batteryboirecharged"

  desc "Sync code signing certificates using match"
  lane :sync_certs do |options|
    type = options[:type] || "developer_id"
    readonly = options[:readonly].nil? ? is_ci : options[:readonly]

    match(
      type: type,
      readonly: readonly,
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
    )
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: PROJECT,
      scheme: SCHEME,
      destination: "platform=macOS",
      clean: true,
      code_coverage: true,
      xcargs: "CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO SWIFT_STRICT_CONCURRENCY=minimal"
    )
  end

  desc "Build release app with signing"
  lane :build do
    setup_ci if ENV["CI"]

    # Sync certificates
    sync_certs(type: "developer_id", readonly: is_ci)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build the app
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true
    )

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end
  end

  desc "Build, sign, notarize and create DMG for release"
  lane :release do
    setup_ci if ENV["CI"]

    # Map GitHub workflow env vars to fastlane-specific env vars
    ENV['FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD'] = ENV['APPLE_APP_PASSWORD'] if ENV['APPLE_APP_PASSWORD']

    # Sync certificates
    sync_certs(type: "developer_id", readonly: is_ci)

    # Get version
    version = get_version_number(xcodeproj: PROJECT, target: SCHEME)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build app with hardened runtime explicitly enabled
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true,
      xcargs: "OTHER_CODE_SIGN_FLAGS='--timestamp --options runtime'"
    )

    # Re-sign Sparkle framework components with Developer ID certificate
    # Required for notarization - Sparkle binaries from SPM aren't signed with our cert

    # Get the actual app path - it might be in the archive, not in ./build
    archive_path = lane_context[SharedValues::XCODEBUILD_ARCHIVE]
    app_path = "./build/#{SCHEME}.app"

    # If the app doesn't exist in ./build, look in the archive
    if !File.exist?(app_path) && archive_path
      archive_app_path = "#{archive_path}/Products/Applications/#{SCHEME}.app"
      if File.exist?(archive_app_path)
        UI.important("App not found in ./build, using archive path: #{archive_app_path}")
        app_path = archive_app_path
      end
    end

    UI.message("Looking for Sparkle framework in: #{app_path}")
    sparkle_framework = "#{app_path}/Contents/Frameworks/Sparkle.framework"

    if File.exist?(app_path)
      UI.message("App exists at: #{app_path}")
      # List contents to debug
      UI.message("App contents:")
      sh("ls -la '#{app_path}/Contents' || true")
      sh("ls -la '#{app_path}/Contents/Frameworks' || true")
    else
      UI.error("App not found at: #{app_path}")
    end

    if File.exist?(sparkle_framework)
      UI.message("Re-signing Sparkle framework components...")

      # Find the exact Developer ID certificate identity
      # Critical: Must use the FULL identity string, not just "Developer ID Application"
      cert_identity = sh("security find-identity -v -p codesigning | grep 'Developer ID Application' | head -1 | grep -o '\"[^\"]*\"' | tr -d '\"'").strip
      UI.important("Using certificate: #{cert_identity}")

      # Find the version directory
      versions_base = "#{sparkle_framework}/Versions"
      version_dir = nil
      if Dir.exist?(versions_base)
        ['Current', 'B', 'A'].each do |ver|
          candidate = "#{versions_base}/#{ver}"
          if Dir.exist?(candidate) && !File.symlink?(candidate)
            version_dir = candidate
            break
          elsif ver == 'Current' && File.symlink?(candidate)
            version_dir = File.realpath(candidate)
            break
          end
        end
      end

      if version_dir
        UI.message("Found Sparkle version: #{File.basename(version_dir)}")

        # Phase 1: Sign XPC service executables with preserved entitlements
        xpc_dir = "#{version_dir}/XPCServices"
        if Dir.exist?(xpc_dir)
          Dir.glob("#{xpc_dir}/*.xpc").sort.each do |xpc|
            xpc_name = File.basename(xpc, '.xpc')
            xpc_binary = "#{xpc}/Contents/MacOS/#{xpc_name}"
            if File.exist?(xpc_binary)
              # Extract existing entitlements
              entitlements_file = "/tmp/#{xpc_name}.entitlements"
              sh("codesign -d --entitlements '#{entitlements_file}' '#{xpc_binary}' 2>/dev/null || true")

              # Sign with entitlements if they exist
              if File.exist?(entitlements_file) && File.size(entitlements_file) > 0
                sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime --entitlements '#{entitlements_file}' '#{xpc_binary}'")
              else
                sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{xpc_binary}'")
              end
              UI.success("Signed: #{xpc_name} executable")
            end

            # Sign the XPC bundle itself
            sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{xpc}'")
            UI.success("Signed: #{xpc_name}.xpc")
          end
        end

        # Phase 2: Sign nested app executables and bundles
        Dir.glob("#{version_dir}/*.app").sort.each do |app|
          app_name = File.basename(app, '.app')
          app_binary = "#{app}/Contents/MacOS/#{app_name}"
          if File.exist?(app_binary)
            sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{app_binary}'")
            UI.success("Signed: #{app_name} executable")
          end
          sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{app}'")
          UI.success("Signed: #{app_name}.app")
        end

        # Phase 3: Sign standalone executables
        ['Autoupdate', 'updater'].each do |exec_name|
          exec_path = "#{version_dir}/#{exec_name}"
          if File.exist?(exec_path) && File.executable?(exec_path)
            sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{exec_path}'")
            UI.success("Signed: #{exec_name}")
          end
        end
      end

      # Phase 4: Sign the framework itself
      sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{sparkle_framework}'")
      UI.success("Signed: Sparkle.framework")

      # Phase 5: Sign the main app (without --deep, all nested code is already signed)
      UI.message("Re-signing main app bundle...")
      sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{app_path}'")
      UI.success("Main app re-signed successfully")

      # Verify the signature
      UI.message("Verifying code signature...")
      sh("codesign --verify --deep --strict --verbose=2 '#{app_path}'")
      UI.success("Code signature verification passed")

      # If we modified the app in the archive, copy it to ./build
      if app_path.include?("xcarchive")
        build_app_path = "./build/#{SCHEME}.app"
        UI.message("Copying re-signed app from archive to build directory...")
        sh("mkdir -p ./build")
        sh("rm -rf '#{build_app_path}'") if File.exist?(build_app_path)
        sh("cp -R '#{app_path}' '#{build_app_path}'")
        UI.success("App copied to: #{build_app_path}")
      end
    else
      UI.important("Sparkle framework not found at: #{sparkle_framework}")
    end

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end

    # Notarize
    app_path = "./build/#{SCHEME}.app"
    UI.message("Starting notarization for: #{app_path}")
    UI.message("Bundle ID: #{BUNDLE_ID}")

    begin
      notarize(
        package: app_path,
        bundle_id: BUNDLE_ID,
        username: ENV["APPLE_ID"],
        asc_provider: ENV["APPLE_TEAM_ID"],
        verbose: true
      )
      UI.success("Notarization completed successfully")
    rescue => ex
      UI.error("Notarization failed: #{ex.message}")
      UI.important("Common causes:")
      UI.important("  1. App-specific password expired or invalid")
      UI.important("  2. Code signing or hardened runtime issues")
      UI.important("  3. Team ID mismatch")
      raise ex
    end

    # Staple
    sh("xcrun stapler staple '#{app_path}'")

    # Create DMG
    dmg_path = "./build/#{SCHEME}-#{version}.dmg"
    sh("mkdir -p ./build/dmg")
    sh("cp -R '#{app_path}' ./build/dmg/")
    sh("ln -s /Applications ./build/dmg/Applications")
    sh("hdiutil create -volname '#{SCHEME}' -srcfolder ./build/dmg -ov -format UDZO '#{dmg_path}'")
    sh("rm -rf ./build/dmg")

    # Sign DMG with Sparkle
    if ENV["SPARKLE_PRIVATE_KEY"]
      sh("curl -L -o /tmp/Sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz")
      sh("mkdir -p /tmp/Sparkle && tar -xf /tmp/Sparkle.tar.xz -C /tmp/Sparkle")
      signature = sh("/tmp/Sparkle/bin/sign_update '#{dmg_path}' --ed-key-file <(echo \"$SPARKLE_PRIVATE_KEY\")").strip
      File.write("./build/sparkle_signature.txt", signature)
    end

    UI.success("Release complete: #{dmg_path}")
  end
end

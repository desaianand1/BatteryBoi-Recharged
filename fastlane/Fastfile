default_platform(:mac)

platform :mac do
  SCHEME = "BatteryBoi - Recharged"
  PROJECT = "BatteryBoi.xcodeproj"
  BUNDLE_ID = "com.nirnshard.batteryboirecharged"

  desc "Sync code signing certificates using match"
  lane :sync_certs do |options|
    type = options[:type] || "developer_id"
    readonly = options[:readonly].nil? ? is_ci : options[:readonly]

    match(
      type: type,
      readonly: readonly,
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
    )
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: PROJECT,
      scheme: SCHEME,
      destination: "platform=macOS",
      clean: true,
      code_coverage: true,
      xcargs: "CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO SWIFT_STRICT_CONCURRENCY=complete OTHER_SWIFT_FLAGS='-DMACOS_13_AND_ABOVE'"
    )
  end

  desc "Build release app with signing"
  lane :build do
    setup_ci if ENV["CI"]

    # Sync certificates (readonly: true to skip Developer Portal verification)
    sync_certs(type: "developer_id", readonly: true)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build the app
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true
    )

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end
  end

  desc "Build, sign, notarize and create DMG for release"
  lane :release do
    setup_ci if ENV["CI"]

    # Validate required environment variables
    required_env_vars = %w[APPLE_ID APPLE_APP_PASSWORD APPLE_TEAM_ID]
    missing_vars = required_env_vars.select { |var| ENV[var].nil? || ENV[var].empty? }
    unless missing_vars.empty?
      UI.user_error!("Missing required environment variables: #{missing_vars.join(', ')}")
    end

    # Map GitHub workflow env vars to fastlane-specific env vars
    ENV['FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD'] = ENV['APPLE_APP_PASSWORD']

    # Sync certificates (readonly: true to skip Developer Portal verification)
    sync_certs(type: "developer_id", readonly: true)

    # Get version
    version = get_version_number(xcodeproj: PROJECT, target: SCHEME)

    # Configure code signing for Developer ID (required for notarization)
    # This must run for ALL builds, not just CI, to ensure correct signing
    update_code_signing_settings(
      use_automatic_signing: false,
      path: PROJECT,
      team_id: ENV["APPLE_TEAM_ID"],
      code_sign_identity: "Developer ID Application",
      profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
      targets: ["BatteryBoi - Recharged"]
    )

    # Build app with hardened runtime explicitly enabled
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true,
      xcargs: "OTHER_CODE_SIGN_FLAGS='--timestamp --options runtime'"
    )

    # Post-build: Re-sign all code with Developer ID for notarization
    app_path = "./build/#{SCHEME}.app"

    # Verify app exists - check archive if not in build directory
    unless File.exist?(app_path)
      archive_path = lane_context[SharedValues::XCODEBUILD_ARCHIVE]
      if archive_path
        archive_app = "#{archive_path}/Products/Applications/#{SCHEME}.app"
        if File.exist?(archive_app)
          sh("mkdir -p ./build")
          sh("cp -R '#{archive_app}' '#{app_path}'")
          UI.success("Copied app from archive to build directory")
        end
      end
    end

    UI.user_error!("App not found at #{app_path}") unless File.exist?(app_path)

    # Get Developer ID certificate
    cert_identity = sh("security find-identity -v -p codesigning | grep 'Developer ID Application' | head -1 | sed 's/.*\"\\(.*\\)\"/\\1/'").strip
    UI.user_error!("Developer ID Application certificate not found in keychain") if cert_identity.empty?
    UI.important("Using certificate: #{cert_identity}")

    # Remove XPC services (not needed for non-sandboxed apps)
    # Using sh() because FileUtils.rm_rf doesn't always work reliably
    xpc_path = "#{app_path}/Contents/Frameworks/Sparkle.framework/Versions/B/XPCServices"
    if Dir.exist?(xpc_path)
      UI.message("Removing Sparkle XPC services...")
      sh("rm -rf '#{xpc_path}'")
      UI.success("Removed XPC services")
    end

    # Sign Sparkle framework components explicitly (innermost first)
    # This is more reliable than trying to discover binaries automatically
    sparkle_path = "#{app_path}/Contents/Frameworks/Sparkle.framework/Versions/B"

    if Dir.exist?(sparkle_path)
      UI.message("Signing Sparkle framework components...")

      # Sign Autoupdate binary
      autoupdate = "#{sparkle_path}/Autoupdate"
      if File.exist?(autoupdate)
        sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{autoupdate}'")
        UI.message("  Signed Autoupdate")
      end

      # Sign Updater.app binary then bundle
      updater_binary = "#{sparkle_path}/Updater.app/Contents/MacOS/Updater"
      updater_app = "#{sparkle_path}/Updater.app"
      if File.exist?(updater_binary)
        sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{updater_binary}'")
        UI.message("  Signed Updater binary")
      end
      if Dir.exist?(updater_app)
        sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{updater_app}'")
        UI.message("  Signed Updater.app")
      end

      # Sign Sparkle binary
      sparkle_binary = "#{sparkle_path}/Sparkle"
      if File.exist?(sparkle_binary)
        sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{sparkle_binary}'")
        UI.message("  Signed Sparkle binary")
      end

      # Sign Sparkle.framework bundle
      sparkle_fw = "#{app_path}/Contents/Frameworks/Sparkle.framework"
      sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{sparkle_fw}'")
      UI.message("  Signed Sparkle.framework")
    end

    # Sign any other frameworks (e.g., Sentry)
    other_frameworks = Dir.glob("#{app_path}/Contents/Frameworks/*.framework").reject { |f| f.include?("Sparkle") }
    other_frameworks.each do |fw|
      UI.message("Signing #{File.basename(fw)}...")
      sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{fw}'")
    end

    # Sign main app binary then bundle
    main_binary = "#{app_path}/Contents/MacOS/#{SCHEME}"
    sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{main_binary}'")
    UI.message("  Signed main binary")

    sh("codesign --force --sign '#{cert_identity}' --timestamp --options runtime '#{app_path}'")
    UI.message("  Signed main app bundle")

    # Verify BEFORE notarization
    UI.message("Verifying code signature...")
    sh("codesign --verify --deep --strict --verbose=2 '#{app_path}'")

    # Check that it's actually signed with Developer ID
    verify_output = sh("codesign -dvv '#{app_path}' 2>&1")
    unless verify_output.include?("Developer ID Application")
      UI.user_error!("App is not signed with Developer ID Application certificate!")
    end

    UI.success("All code signed with Developer ID Application")

    # Restore automatic signing in project (so Xcode works normally)
    update_code_signing_settings(
      use_automatic_signing: true,
      path: PROJECT
    )

    # Notarize using xcrun notarytool directly (fastlane's notarize action has JSON parsing bugs)
    app_path = "./build/#{SCHEME}.app"
    zip_path = "./build/#{SCHEME}.zip"
    UI.message("Starting notarization for: #{app_path}")

    # Create zip for notarization (notarytool requires zip/dmg/pkg)
    sh("ditto -c -k --keepParent '#{app_path}' '#{zip_path}'")
    UI.message("Created zip archive for notarization")

    # Submit for notarization and wait
    UI.message("Submitting to Apple notary service...")
    notarize_output = sh("xcrun notarytool submit '#{zip_path}' --apple-id '#{ENV['APPLE_ID']}' --password '#{ENV['APPLE_APP_PASSWORD']}' --team-id '#{ENV['APPLE_TEAM_ID']}' --wait 2>&1")

    if notarize_output.include?("status: Accepted")
      UI.success("Notarization completed successfully")
    else
      # Extract submission ID and fetch log
      if notarize_output =~ /id:\s*([a-f0-9-]{36})/i
        submission_id = $1
        UI.important("Fetching notarization log for submission: #{submission_id}")
        log_output = sh("xcrun notarytool log '#{submission_id}' --apple-id '#{ENV['APPLE_ID']}' --password '#{ENV['APPLE_APP_PASSWORD']}' --team-id '#{ENV['APPLE_TEAM_ID']}' 2>&1 || true")
        UI.important("========== APPLE NOTARIZATION LOG ==========")
        UI.important(log_output)
        UI.important("========== END NOTARIZATION LOG ==========")
      end
      UI.user_error!("Notarization failed. See log above for details.")
    end

    # Clean up zip
    sh("rm -f '#{zip_path}'")

    # Staple
    sh("xcrun stapler staple '#{app_path}'")

    # Create DMG
    dmg_path = "./build/#{SCHEME}-#{version}.dmg"
    sh("mkdir -p ./build/dmg")
    sh("cp -R '#{app_path}' ./build/dmg/")
    sh("ln -s /Applications ./build/dmg/Applications")
    sh("hdiutil create -volname '#{SCHEME}' -srcfolder ./build/dmg -ov -format UDZO '#{dmg_path}'")
    sh("rm -rf ./build/dmg")

    # Sign DMG with Sparkle EdDSA signature for auto-updates
    if ENV["SPARKLE_PRIVATE_KEY"] && !ENV["SPARKLE_PRIVATE_KEY"].empty?
      UI.message("Signing DMG with Sparkle EdDSA key...")
      sh("curl -L -o /tmp/Sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz")
      sh("mkdir -p /tmp/Sparkle && tar -xf /tmp/Sparkle.tar.xz -C /tmp/Sparkle")
      # Write key to temp file to avoid shell escaping issues with process substitution
      key_file = "/tmp/sparkle_ed_key"
      File.write(key_file, ENV["SPARKLE_PRIVATE_KEY"])
      begin
        signature = sh("/tmp/Sparkle/bin/sign_update '#{dmg_path}' --ed-key-file '#{key_file}'").strip
        File.write("./build/sparkle_signature.txt", signature)
        UI.success("Sparkle signature generated")
      ensure
        # Clean up key file
        FileUtils.rm_f(key_file)
      end
    else
      UI.important("SPARKLE_PRIVATE_KEY not set, skipping DMG signing for auto-updates")
    end

    UI.success("Release complete: #{dmg_path}")
  end
end

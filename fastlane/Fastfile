default_platform(:mac)

platform :mac do
  SCHEME = "BatteryBoi - Recharged"
  PROJECT = "BatteryBoi.xcodeproj"
  BUNDLE_ID = "com.nirnshard.batteryboirecharged"

  desc "Sync code signing certificates using match"
  lane :sync_certs do |options|
    type = options[:type] || "developer_id"
    readonly = options[:readonly].nil? ? is_ci : options[:readonly]

    match(
      type: type,
      readonly: readonly,
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
    )
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: PROJECT,
      scheme: SCHEME,
      destination: "platform=macOS",
      clean: true,
      code_coverage: true,
      xcargs: "CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO SWIFT_STRICT_CONCURRENCY=minimal"
    )
  end

  desc "Build release app with signing"
  lane :build do
    setup_ci if ENV["CI"]

    # Sync certificates
    sync_certs(type: "developer_id", readonly: is_ci)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build the app
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true
    )

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end
  end

  desc "Build, sign, notarize and create DMG for release"
  lane :release do
    setup_ci if ENV["CI"]

    # Map GitHub workflow env vars to fastlane-specific env vars
    ENV['FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD'] = ENV['APPLE_APP_PASSWORD'] if ENV['APPLE_APP_PASSWORD']

    # Sync certificates
    sync_certs(type: "developer_id", readonly: is_ci)

    # Get version
    version = get_version_number(xcodeproj: PROJECT, target: SCHEME)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build app
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true
    )

    # Re-sign Sparkle framework components with Developer ID certificate
    # Required for notarization - Sparkle binaries from SPM aren't signed with our cert

    # Get the actual app path - it might be in the archive, not in ./build
    archive_path = lane_context[SharedValues::XCODEBUILD_ARCHIVE]
    app_path = "./build/#{SCHEME}.app"

    # If the app doesn't exist in ./build, look in the archive
    if !File.exist?(app_path) && archive_path
      archive_app_path = "#{archive_path}/Products/Applications/#{SCHEME}.app"
      if File.exist?(archive_app_path)
        UI.important("App not found in ./build, using archive path: #{archive_app_path}")
        app_path = archive_app_path
      end
    end

    UI.message("Looking for Sparkle framework in: #{app_path}")
    sparkle_framework = "#{app_path}/Contents/Frameworks/Sparkle.framework"

    if File.exist?(app_path)
      UI.message("App exists at: #{app_path}")
      # List contents to debug
      UI.message("App contents:")
      sh("ls -la '#{app_path}/Contents' || true")
      sh("ls -la '#{app_path}/Contents/Frameworks' || true")
    else
      UI.error("App not found at: #{app_path}")
    end

    if File.exist?(sparkle_framework)
      UI.message("Re-signing Sparkle framework components...")

      # Discover and sign all executables and nested bundles in Sparkle framework
      # Must sign from innermost to outermost
      components_to_sign = []

      # Find the actual version directory (could be A, B, or Current symlink)
      versions_base = "#{sparkle_framework}/Versions"
      version_dir = nil
      if Dir.exist?(versions_base)
        # Try common version directories
        ['Current', 'B', 'A'].each do |ver|
          candidate = "#{versions_base}/#{ver}"
          if Dir.exist?(candidate) && !File.symlink?(candidate)
            version_dir = candidate
            break
          # If Current is a symlink, resolve it
          elsif ver == 'Current' && File.symlink?(candidate)
            version_dir = File.realpath(candidate)
            break
          end
        end
      end

      if version_dir
        UI.message("Found Sparkle version directory: #{File.basename(version_dir)}")

        # Find XPC services
        xpc_dir = "#{version_dir}/XPCServices"
        if Dir.exist?(xpc_dir)
          Dir.glob("#{xpc_dir}/*.xpc").sort.each do |xpc|
            components_to_sign << xpc
            UI.message("  Found XPC service: #{File.basename(xpc)}")
          end
        end

        # Find nested apps
        Dir.glob("#{version_dir}/*.app").sort.each do |app|
          components_to_sign << app
          UI.message("  Found nested app: #{File.basename(app)}")
        end

        # Find standalone executables
        ['Autoupdate', 'updater'].each do |exec_name|
          exec_path = "#{version_dir}/#{exec_name}"
          if File.exist?(exec_path) && File.executable?(exec_path)
            components_to_sign << exec_path
            UI.message("  Found executable: #{exec_name}")
          end
        end
      else
        UI.important("Could not find Sparkle Versions directory, will sign framework only")
      end

      # Always add the framework itself last (outermost)
      components_to_sign << sparkle_framework

      # Log summary
      if components_to_sign.length == 1
        UI.important("No nested components found, signing framework only")
      else
        UI.message("Signing #{components_to_sign.length} components (including framework)")
      end

      # Sign all components
      components_to_sign.each do |component|
        sh("codesign --force --sign 'Developer ID Application' --timestamp --options runtime '#{component}'")
        UI.success("Signed: #{File.basename(component)}")
      end

      # Re-sign the main app to encompass the Sparkle framework changes
      # Critical: modifying embedded frameworks invalidates the parent app's signature
      UI.message("Re-signing main app bundle to encompass framework changes...")
      sh("codesign --force --sign 'Developer ID Application' --timestamp --options runtime '#{app_path}'")
      UI.success("Main app re-signed successfully")

      # Verify the signature
      UI.message("Verifying code signature...")
      sh("codesign --verify --deep --strict --verbose=2 '#{app_path}'")
      UI.success("Code signature verification passed")

      # If we modified the app in the archive, copy it to ./build
      if app_path.include?("xcarchive")
        build_app_path = "./build/#{SCHEME}.app"
        UI.message("Copying re-signed app from archive to build directory...")
        sh("rm -rf '#{build_app_path}'") if File.exist?(build_app_path)
        sh("cp -R '#{app_path}' '#{build_app_path}'")
        UI.success("App copied to: #{build_app_path}")
      end
    else
      UI.important("Sparkle framework not found at: #{sparkle_framework}")
    end

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end

    # Notarize
    app_path = "./build/#{SCHEME}.app"
    UI.message("Starting notarization for: #{app_path}")
    UI.message("Bundle ID: #{BUNDLE_ID}")

    begin
      notarize(
        package: app_path,
        bundle_id: BUNDLE_ID,
        username: ENV["APPLE_ID"],
        asc_provider: ENV["APPLE_TEAM_ID"],
        verbose: true
      )
      UI.success("Notarization completed successfully")
    rescue => ex
      UI.error("Notarization failed: #{ex.message}")
      UI.important("Common causes:")
      UI.important("  1. App-specific password expired or invalid")
      UI.important("  2. Code signing or hardened runtime issues")
      UI.important("  3. Team ID mismatch")
      raise ex
    end

    # Staple
    sh("xcrun stapler staple '#{app_path}'")

    # Create DMG
    dmg_path = "./build/#{SCHEME}-#{version}.dmg"
    sh("mkdir -p ./build/dmg")
    sh("cp -R '#{app_path}' ./build/dmg/")
    sh("ln -s /Applications ./build/dmg/Applications")
    sh("hdiutil create -volname '#{SCHEME}' -srcfolder ./build/dmg -ov -format UDZO '#{dmg_path}'")
    sh("rm -rf ./build/dmg")

    # Sign DMG with Sparkle
    if ENV["SPARKLE_PRIVATE_KEY"]
      sh("curl -L -o /tmp/Sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz")
      sh("mkdir -p /tmp/Sparkle && tar -xf /tmp/Sparkle.tar.xz -C /tmp/Sparkle")
      signature = sh("/tmp/Sparkle/bin/sign_update '#{dmg_path}' --ed-key-file <(echo \"$SPARKLE_PRIVATE_KEY\")").strip
      File.write("./build/sparkle_signature.txt", signature)
    end

    UI.success("Release complete: #{dmg_path}")
  end
end

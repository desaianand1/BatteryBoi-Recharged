default_platform(:mac)

platform :mac do
  SCHEME = "BatteryBoi - Recharged"
  PROJECT = "BatteryBoi.xcodeproj"
  BUNDLE_ID = "com.nirnshard.batteryboirecharged"

  desc "Sync code signing certificates using match"
  lane :sync_certs do |options|
    type = options[:type] || "developer_id"
    readonly = options[:readonly].nil? ? is_ci : options[:readonly]

    match(
      type: type,
      readonly: readonly,
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
    )
  end

  desc "Run tests"
  lane :test do
    run_tests(
      project: PROJECT,
      scheme: SCHEME,
      destination: "platform=macOS",
      clean: true,
      code_coverage: true,
      xcargs: "CODE_SIGN_IDENTITY=\"\" CODE_SIGNING_REQUIRED=NO SWIFT_STRICT_CONCURRENCY=minimal"
    )
  end

  desc "Build release app with signing"
  lane :build do
    setup_ci if ENV["CI"]

    # Sync certificates
    sync_certs(type: "developer_id", readonly: is_ci)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build the app
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true
    )

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end
  end

  desc "Build, sign, notarize and create DMG for release"
  lane :release do
    setup_ci if ENV["CI"]

    # Map GitHub workflow env vars to fastlane-specific env vars
    ENV['FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD'] = ENV['APPLE_APP_PASSWORD'] if ENV['APPLE_APP_PASSWORD']

    # Sync certificates
    sync_certs(type: "developer_id", readonly: is_ci)

    # Get version
    version = get_version_number(xcodeproj: PROJECT, target: SCHEME)

    # Configure code signing for CI builds
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: false,
        path: PROJECT,
        team_id: ENV["APPLE_TEAM_ID"],
        code_sign_identity: "Developer ID Application",
        profile_name: "match Direct com.nirnshard.batteryboirecharged macos",
        targets: ["BatteryBoi - Recharged"]
      )
    end

    # Build app
    build_mac_app(
      scheme: SCHEME,
      configuration: "Release",
      output_directory: "./build",
      export_method: "developer-id",
      skip_package_pkg: true
    )

    # Re-sign Sparkle framework components with Developer ID certificate
    # Required for notarization - Sparkle binaries from SPM aren't signed with our cert
    app_path = "./build/#{SCHEME}.app"
    sparkle_framework = "#{app_path}/Contents/Frameworks/Sparkle.framework"

    UI.message("Re-signing Sparkle framework components...")

    # Sign from innermost to outermost (XPC services, nested apps, executables, then framework)
    [
      "#{sparkle_framework}/Versions/B/XPCServices/Installer.xpc",
      "#{sparkle_framework}/Versions/B/XPCServices/Downloader.xpc",
      "#{sparkle_framework}/Versions/B/Updater.app",
      "#{sparkle_framework}/Versions/B/Autoupdate",
      sparkle_framework
    ].each do |component|
      if File.exist?(component)
        sh("codesign --force --sign 'Developer ID Application' --timestamp --options runtime '#{component}'")
        UI.success("Signed: #{File.basename(component)}")
      else
        UI.error("Component not found: #{component}")
        UI.user_error!("Required Sparkle component missing: #{component}")
      end
    end

    # Re-sign the main app to encompass the Sparkle framework changes
    # Critical: modifying embedded frameworks invalidates the parent app's signature
    UI.message("Re-signing main app bundle to encompass framework changes...")
    sh("codesign --force --sign 'Developer ID Application' --timestamp --options runtime '#{app_path}'")
    UI.success("Main app re-signed successfully")

    # Verify the signature
    UI.message("Verifying code signature...")
    sh("codesign --verify --deep --strict --verbose=2 '#{app_path}'")
    UI.success("Code signature verification passed")

    # Re-enable automatic code signing
    if ENV["CI"]
      update_code_signing_settings(
        use_automatic_signing: true,
        path: PROJECT
      )
    end

    # Notarize
    app_path = "./build/#{SCHEME}.app"
    UI.message("Starting notarization for: #{app_path}")
    UI.message("Bundle ID: #{BUNDLE_ID}")

    begin
      notarize(
        package: app_path,
        bundle_id: BUNDLE_ID,
        username: ENV["APPLE_ID"],
        asc_provider: ENV["APPLE_TEAM_ID"],
        print_log: true,
        verbose: true
      )
      UI.success("Notarization completed successfully")
    rescue => ex
      UI.error("Notarization failed: #{ex.message}")
      UI.important("Common causes:")
      UI.important("  1. App-specific password expired or invalid")
      UI.important("  2. Code signing or hardened runtime issues")
      UI.important("  3. Team ID mismatch")
      raise ex
    end

    # Staple
    sh("xcrun stapler staple '#{app_path}'")

    # Create DMG
    dmg_path = "./build/#{SCHEME}-#{version}.dmg"
    sh("mkdir -p ./build/dmg")
    sh("cp -R '#{app_path}' ./build/dmg/")
    sh("ln -s /Applications ./build/dmg/Applications")
    sh("hdiutil create -volname '#{SCHEME}' -srcfolder ./build/dmg -ov -format UDZO '#{dmg_path}'")
    sh("rm -rf ./build/dmg")

    # Sign DMG with Sparkle
    if ENV["SPARKLE_PRIVATE_KEY"]
      sh("curl -L -o /tmp/Sparkle.tar.xz https://github.com/sparkle-project/Sparkle/releases/download/2.8.1/Sparkle-2.8.1.tar.xz")
      sh("mkdir -p /tmp/Sparkle && tar -xf /tmp/Sparkle.tar.xz -C /tmp/Sparkle")
      signature = sh("/tmp/Sparkle/bin/sign_update '#{dmg_path}' --ed-key-file <(echo \"$SPARKLE_PRIVATE_KEY\")").strip
      File.write("./build/sparkle_signature.txt", signature)
    end

    UI.success("Release complete: #{dmg_path}")
  end
end
